package net.splatcraft.loot;

import com.mojang.datafixers.Products;
import com.mojang.serialization.Codec;
import com.mojang.serialization.Lifecycle;
import com.mojang.serialization.MapCodec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import net.minecraft.item.ItemStack;
import net.minecraft.loot.condition.LootCondition;
import net.minecraft.loot.context.LootContext;
import net.minecraft.registry.Registry;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.SimpleRegistry;
import net.minecraft.util.Identifier;
import net.splatcraft.Splatcraft;

import java.util.List;
import java.util.function.Predicate;

// frankestein code from https://github.com/neoforged/NeoForge/blob/79d86eb0a94a29652901bcd8a93f4e0817296a80/src/main/java/net/neoforged/neoforge/common/loot/LootModifier.java#L23
// i love STEALING code (so i can compile this mod literally i couldn't for the past week why does architectury have like 30% of forge events)
public abstract class SplatcraftLootModifier
{
    public static final RegistryKey<Registry<MapCodec<? extends SplatcraftLootModifier>>> GLOBAL_LOOT_MODIFIER_SERIALIZERS_KEY = RegistryKey.ofRegistry(Identifier.of(Splatcraft.MODID, "global_loot_modifier_serializers_dummy"));
    public static final Registry<MapCodec<? extends SplatcraftLootModifier>> GLOBAL_LOOT_MODIFIER_SERIALIZERS;
    /*static Codec<SplatcraftLootModifier> DIRECT_CODEC = GLOBAL_LOOT_MODIFIER_SERIALIZERS.getEntryCodec()
        .dispatch(SplatcraftLootModifier::codec, Function.identity());*/
    static Codec<LootCondition[]> LOOT_CONDITIONS_CODEC = LootCondition.CODEC.listOf().xmap(list -> list.toArray(LootCondition[]::new), List::of);

    static
    {
        GLOBAL_LOOT_MODIFIER_SERIALIZERS = new SimpleRegistry<>(GLOBAL_LOOT_MODIFIER_SERIALIZERS_KEY, Lifecycle.stable(), false);
    }

    protected final LootCondition[] conditions;
    protected final Predicate<LootContext> combinedConditions;

    protected SplatcraftLootModifier(LootCondition[] conditions, Predicate<LootContext> combinedConditions)
    {
        this.conditions = conditions;
        this.combinedConditions = combinedConditions;
    }

    /**
     * Simplifies codec creation, especially if no other fields are added:
     * <p>
     * {@code
     * public static final Codec<MyLootModifier> CODEC = RecordCodecBuilder.create(inst -> codecStart(inst).apply(inst, MyLootModifier::new));
     * }
     * </p>
     * Otherwise can follow this with #and() to add more fields.
     */
    protected static <T extends SplatcraftLootModifier> Products.P1<RecordCodecBuilder.Mu<T>, LootCondition[]> codecStart(RecordCodecBuilder.Instance<T> instance)
    {
        return instance.group(LOOT_CONDITIONS_CODEC.fieldOf("conditions").forGetter(lm -> lm.conditions));
    }

    public abstract Codec<? extends SplatcraftLootModifier> codec();

    public final ObjectArrayList<ItemStack> apply(ObjectArrayList<ItemStack> generatedLoot, LootContext context)
    {
        return combinedConditions.test(context) ? doApply(generatedLoot, context) : generatedLoot;
    }

    /**
     * Applies the modifier to the generated loot (all loot conditions have already been checked
     * and have returned true).
     *
     * @param generatedLoot the list of ItemStacks that will be dropped, generated by loot tables
     * @param context       the LootContext, identical to what is passed to loot tables
     * @return modified loot drops
     */

    protected abstract ObjectArrayList<ItemStack> doApply(ObjectArrayList<ItemStack> generatedLoot, LootContext context);
}
